<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `BinaryHeap` struct in crate `bitflags`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, BinaryHeap">

    <title>bitflags::__core::collections::binary_heap::BinaryHeap - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../../../index.html'>bitflags</a>::<wbr><a href='../../index.html'>__core</a>::<wbr><a href='../index.html'>collections</a>::<wbr><a href='index.html'>binary_heap</a></p><script>window.sidebarCurrent = {name: 'BinaryHeap', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../../../index.html'>bitflags</a>::<wbr><a href='../../index.html'>__core</a>::<wbr><a href='../index.html'>collections</a>::<wbr><a href='index.html'>binary_heap</a>::<wbr><a class='struct' href=''>BinaryHeap</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-25' class='srclink' href='https://doc.rust-lang.org/nightly/collections/binary_heap/struct.BinaryHeap.html?gotosrc=25' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct BinaryHeap&lt;T&gt; {
    // some fields omitted
}</pre><span class="since">1.0.0</span><div class='docblock'><p>A priority queue implemented with a binary heap.</p>

<p>This will be a max-heap.</p>

<p>It is a logic error for an item to be modified in such a way that the
item&#39;s ordering relative to any other item, as determined by the <code>Ord</code>
trait, changes while it is in the heap. This is normally only possible
through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;

<span class='comment'>// Type inference lets us omit an explicit type signature (which</span>
<span class='comment'>// would be `BinaryHeap&lt;i32&gt;` in this example).</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();

<span class='comment'>// We can use peek to look at the next item in the heap. In this case,</span>
<span class='comment'>// there&#39;s no items in there yet so we get None.</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>None</span>);

<span class='comment'>// Let&#39;s add some scores...</span>
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>2</span>);

<span class='comment'>// Now peek shows the most important item in the heap.</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>5</span>));

<span class='comment'>// We can check the length of a heap.</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);

<span class='comment'>// We can iterate over the items in the heap, although they are returned in</span>
<span class='comment'>// a random order.</span>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>heap</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}

<span class='comment'>// If we instead pop these scores, they should come back in order.</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>5</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>2</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>None</span>);

<span class='comment'>// We can clear the heap of any remaining items.</span>
<span class='ident'>heap</span>.<span class='ident'>clear</span>();

<span class='comment'>// The heap should now be empty.</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>is_empty</span>())</pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;T&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.with_capacity' class='method'><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(capacity: <a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.usize.html'>usize</a>) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Creates an empty <code>BinaryHeap</code> with a specific capacity.
This preallocates enough memory for <code>capacity</code> elements,
so that the <code>BinaryHeap</code> does not have to be reallocated
until it contains at least that many values.</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.iter' class='method'><code>fn <a href='#method.iter' class='fnname'>iter</a>(&amp;self) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/binary_heap/struct.Iter.html' title='bitflags::__core::collections::binary_heap::Iter'>Iter</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Returns an iterator visiting all values in the underlying vector, in
arbitrary order.</p>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>]);

<span class='comment'>// Print 1, 2, 3, 4 in arbitrary order</span>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>heap</span>.<span class='ident'>iter</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>
</div><h4 id='method.peek' class='method'><code>fn <a href='#method.peek' class='fnname'>peek</a>(&amp;self) -&gt; <a class='enum' href='../../../../bitflags/__core/option/enum.Option.html' title='bitflags::__core::option::Option'>Option</a>&lt;&amp;T&gt;</code></h4>
<div class='docblock'><p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>None</span>);

<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>5</span>));
</pre>
</div><h4 id='method.capacity' class='method'><code>fn <a href='#method.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the number of elements the binary heap can hold without reallocating.</p>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>with_capacity</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.reserve_exact' class='method'><code>fn <a href='#method.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, additional: <a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the
given <code>BinaryHeap</code>. Does nothing if the capacity is already sufficient.</p>

<p>Note that the allocator may give the collection more space than it requests. Therefore
capacity can not be relied upon to be precisely minimal. Prefer <code>reserve</code> if future
insertions are expected.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>reserve_exact</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.reserve' class='method'><code>fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, additional: <a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.usize.html'>usize</a>)</code></h4>
<div class='docblock'><p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the
<code>BinaryHeap</code>. The collection may reserve more space to avoid frequent reallocations.</p>

<h1 id='panics-1' class='section-header'><a href='#panics-1'>Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id='examples-7' class='section-header'><a href='#examples-7'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>reserve</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>4</span>);</pre>
</div><h4 id='method.shrink_to_fit' class='method'><code>fn <a href='#method.shrink_to_fit' class='fnname'>shrink_to_fit</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Discards as much additional capacity as possible.</p>

<h1 id='examples-8' class='section-header'><a href='#examples-8'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span>: <span class='ident'>BinaryHeap</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>with_capacity</span>(<span class='number'>100</span>);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>heap</span>.<span class='ident'>shrink_to_fit</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>capacity</span>() <span class='op'>==</span> <span class='number'>0</span>);</pre>
</div><h4 id='method.pop' class='method'><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; <a class='enum' href='../../../../bitflags/__core/option/enum.Option.html' title='bitflags::__core::option::Option'>Option</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it
is empty.</p>

<h1 id='examples-9' class='section-header'><a href='#examples-9'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>3</span>]);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>3</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.push' class='method'><code>fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, item: T)</code></h4>
<div class='docblock'><p>Pushes an item onto the binary heap.</p>

<h1 id='examples-10' class='section-header'><a href='#examples-10'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>5</span>));</pre>
</div><h4 id='method.push_pop' class='method'><code>fn <a href='#method.push_pop' class='fnname'>push_pop</a>(&amp;mut self, item: T) -&gt; T</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>binary_heap_extras</code>)<p>: needs to be audited</p>
</em></div><div class='docblock'><p>Pushes an item onto the binary heap, then pops the greatest item off the queue in
an optimized fashion.</p>

<h1 id='examples-11' class='section-header'><a href='#examples-11'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>binary_heap_extras</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>push_pop</span>(<span class='number'>3</span>), <span class='number'>5</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>push_pop</span>(<span class='number'>9</span>), <span class='number'>9</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>3</span>));</pre>
</div><h4 id='method.replace' class='method'><code>fn <a href='#method.replace' class='fnname'>replace</a>(&amp;mut self, item: T) -&gt; <a class='enum' href='../../../../bitflags/__core/option/enum.Option.html' title='bitflags::__core::option::Option'>Option</a>&lt;T&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>binary_heap_extras</code>)<p>: needs to be audited</p>
</em></div><div class='docblock'><p>Pops the greatest item off the binary heap, then pushes an item onto the queue in
an optimized fashion. The push is done regardless of whether the binary heap
was empty.</p>

<h1 id='examples-12' class='section-header'><a href='#examples-12'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>binary_heap_extras</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>replace</span>(<span class='number'>1</span>), <span class='prelude-val'>None</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>replace</span>(<span class='number'>3</span>), <span class='prelude-val'>Some</span>(<span class='number'>1</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>peek</span>(), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='number'>3</span>));</pre>
</div><h4 id='method.into_vec' class='method'><span class="since">1.5.0</span><code>fn <a href='#method.into_vec' class='fnname'>into_vec</a>(self) -&gt; <a class='struct' href='../../../../bitflags/__core/vec/struct.Vec.html' title='bitflags::__core::vec::Vec'>Vec</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Consumes the <code>BinaryHeap</code> and returns the underlying vector
in arbitrary order.</p>

<h1 id='examples-13' class='section-header'><a href='#examples-13'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>]);
<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>heap</span>.<span class='ident'>into_vec</span>();

<span class='comment'>// Will print in some order</span>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>vec</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>
</div><h4 id='method.into_sorted_vec' class='method'><span class="since">1.5.0</span><code>fn <a href='#method.into_sorted_vec' class='fnname'>into_sorted_vec</a>(self) -&gt; <a class='struct' href='../../../../bitflags/__core/vec/struct.Vec.html' title='bitflags::__core::vec::Vec'>Vec</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted
(ascending) order.</p>

<h1 id='examples-14' class='section-header'><a href='#examples-14'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>7</span>]);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>6</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>heap</span>.<span class='ident'>into_sorted_vec</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>vec</span>, [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>]);</pre>
</div><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.usize.html'>usize</a></code></h4>
<div class='docblock'><p>Returns the length of the binary heap.</p>

<h1 id='examples-15' class='section-header'><a href='#examples-15'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>3</span>]);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>len</span>(), <span class='number'>2</span>);</pre>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Checks if the binary heap is empty.</p>

<h1 id='examples-16' class='section-header'><a href='#examples-16'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>new</span>();

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>is_empty</span>());

<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>5</span>);
<span class='ident'>heap</span>.<span class='ident'>push</span>(<span class='number'>1</span>);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>heap</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.drain' class='method'><span class="since">1.6.0</span><code>fn <a href='#method.drain' class='fnname'>drain</a>(&amp;mut self) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/binary_heap/struct.Drain.html' title='bitflags::__core::collections::binary_heap::Drain'>Drain</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Clears the binary heap, returning an iterator over the removed elements.</p>

<p>The elements are removed in arbitrary order.</p>

<h1 id='examples-17' class='section-header'><a href='#examples-17'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>3</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>heap</span>.<span class='ident'>is_empty</span>());

<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>heap</span>.<span class='ident'>drain</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Drops all items from the binary heap.</p>

<h1 id='examples-18' class='section-header'><a href='#examples-18'>Examples</a></h1>
<p>Basic usage:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BinaryHeap</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>heap</span> <span class='op'>=</span> <span class='ident'>BinaryHeap</span>::<span class='ident'>from</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>3</span>]);

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>heap</span>.<span class='ident'>is_empty</span>());

<span class='ident'>heap</span>.<span class='ident'>clear</span>();

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>heap</span>.<span class='ident'>is_empty</span>());</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;'a, T&gt; <a class='trait' href='../../../../bitflags/__core/iter/trait.Extend.html' title='bitflags::__core::iter::Extend'>Extend</a>&lt;&amp;'a T&gt; for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/marker/trait.Copy.html' title='bitflags::__core::marker::Copy'>Copy</a> + 'a + <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code><span class="since">1.2.0</span></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../../../bitflags/__core/iter/trait.Extend.html#tymethod.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class='where'>where I: <a class='trait' href='../../../../bitflags/__core/iter/trait.IntoIterator.html' title='bitflags::__core::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a T&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/iter/trait.Extend.html' title='bitflags::__core::iter::Extend'>Extend</a>&lt;T&gt; for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.extend-1' class='method'><code>fn <a href='../../../../bitflags/__core/iter/trait.Extend.html#tymethod.extend' class='fnname'>extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class='where'>where I: <a class='trait' href='../../../../bitflags/__core/iter/trait.IntoIterator.html' title='bitflags::__core::iter::IntoIterator'>IntoIterator</a>&lt;Item=T&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/iter/trait.IntoIterator.html' title='bitflags::__core::iter::IntoIterator'>IntoIterator</a> for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='associatedtype.Item' class='type'><code>type <a href='../../../../bitflags/__core/iter/trait.IntoIterator.html#associatedtype.Item' class='type'>Item</a> = T</code></h4>
<h4 id='associatedtype.IntoIter' class='type'><code>type <a href='../../../../bitflags/__core/iter/trait.IntoIterator.html#associatedtype.IntoIter' class='type'>IntoIter</a> = <a class='struct' href='../../../../bitflags/__core/collections/binary_heap/struct.IntoIter.html' title='bitflags::__core::collections::binary_heap::IntoIter'>IntoIter</a>&lt;T&gt;</code></h4>
<h4 id='method.into_iter' class='method'><code>fn <a href='../../../../bitflags/__core/iter/trait.IntoIterator.html#tymethod.into_iter' class='fnname'>into_iter</a>(self) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/binary_heap/struct.IntoIter.html' title='bitflags::__core::collections::binary_heap::IntoIter'>IntoIter</a>&lt;T&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/iter/trait.FromIterator.html' title='bitflags::__core::iter::FromIterator'>FromIterator</a>&lt;T&gt; for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><code>fn <a href='../../../../bitflags/__core/iter/trait.FromIterator.html#tymethod.from_iter' class='fnname'>from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where I: <a class='trait' href='../../../../bitflags/__core/iter/trait.IntoIterator.html' title='bitflags::__core::iter::IntoIterator'>IntoIterator</a>&lt;Item=T&gt;</span></code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/convert/trait.From.html' title='bitflags::__core::convert::From'>From</a>&lt;<a class='struct' href='../../../../bitflags/__core/vec/struct.Vec.html' title='bitflags::__core::vec::Vec'>Vec</a>&lt;T&gt;&gt; for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.from' class='method'><code>fn <a href='../../../../bitflags/__core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(vec: <a class='struct' href='../../../../bitflags/__core/vec/struct.Vec.html' title='bitflags::__core::vec::Vec'>Vec</a>&lt;T&gt;) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/fmt/trait.Debug.html' title='bitflags::__core::fmt::Debug'>Debug</a> for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a> + <a class='trait' href='../../../../bitflags/__core/fmt/trait.Debug.html' title='bitflags::__core::fmt::Debug'>Debug</a></span></code><span class="since">1.4.0</span></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='../../../../bitflags/__core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../../../bitflags/__core/fmt/struct.Formatter.html' title='bitflags::__core::fmt::Formatter'>Formatter</a>) -&gt; <a class='enum' href='../../../../bitflags/__core/result/enum.Result.html' title='bitflags::__core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/bitflags/primitive.tuple.html'>()</a>, <a class='struct' href='../../../../bitflags/__core/fmt/struct.Error.html' title='bitflags::__core::fmt::Error'>Error</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/default/trait.Default.html' title='bitflags::__core::default::Default'>Default</a> for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/cmp/trait.Ord.html' title='bitflags::__core::cmp::Ord'>Ord</a></span></code></h3><div class='impl-items'><h4 id='method.default' class='method'><code>fn <a href='../../../../bitflags/__core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
</div><h3 class='impl'><code>impl&lt;T&gt; <a class='trait' href='../../../../bitflags/__core/clone/trait.Clone.html' title='bitflags::__core::clone::Clone'>Clone</a> for <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt; <span class='where'>where T: <a class='trait' href='../../../../bitflags/__core/clone/trait.Clone.html' title='bitflags::__core::clone::Clone'>Clone</a></span></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='../../../../bitflags/__core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt;</code></h4>
<h4 id='method.clone_from' class='method'><code>fn <a href='../../../../bitflags/__core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;<a class='struct' href='../../../../bitflags/__core/collections/struct.BinaryHeap.html' title='bitflags::__core::collections::BinaryHeap'>BinaryHeap</a>&lt;T&gt;)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../../";
        window.currentCrate = "bitflags";
        window.playgroundUrl = "";
    </script>
    <script src="../../../../jquery.js"></script>
    <script src="../../../../main.js"></script>
    
    <script defer src="../../../../search-index.js"></script>
</body>
</html>